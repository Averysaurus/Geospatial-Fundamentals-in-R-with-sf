---
title: Geospatial Data Fundamentals in R
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '/Users/pattyf/Documents/Dlab/workshops/2021/Geospatial-Fundamentals-in-R-with-sf')
```

# Lesson 6. Spatial Queries

Spatial analysis is a process that begins with exploring a dataset and mapping data variables and ends with potentially complex models and visualizations of real world features and phenomena. `Spatial queries` are the building blocks of this process. These queries are software operations that allow us to ask questions of our data and which return data metrics, subsets or new data objects.  In this lesson we explore the two basic types of spatial queries: measurement queries and relationship queries.

- 6.0 Load and prep some data
- 6.1 Measurement Queries
- 6.2 Relationship Queries
- **Exercise**: Spatial Relationship Query
- 6.3 Proximity Analysis
- **Exercise**: Proximity Analysis
- 6.4 Recap


<br>
<font color='grey'>
    <b>Instructor Notes</b>

- Datasets used
    - 'notebook_data/census/Tracts/cb_2013_06_tract_500k.zip'
    - 'notebook_data/census/Places/cb_2018_06_place_500k.shp'
    - 'notebook_data/protected_areas/CPAD_2020a_Units.shp'
    - 'notebook_data/alco_schools.csv'
    - 'notebook_data/transportation/BerkeleyBikeBlvds.geojson'
    - 'notebook_data/transportation/bart.csv'

- Expected time to complete
    - Lecture + Questions: 45 minutes
    - Exercises: 20 minutes
</font>

-------------------

### Types of Spatial Queries

The basic types of **spatial queries** are:

- <u>Measurement queries</u>
    - What is feature A's **length**?
    - What is feature A's **perimeter**?
    - What is feature A's **area**?
    - What is feature A's **distance** from feature B?
    - etc.
    
- <u>Relationship queries</u>
    - Does feature A **intersect** with feature B?
    - Is feature A **within** feature B?
    - Does feature A **cross** feature B?
    - etc.

Both of these types of queries operate on the geometry of features and are dependent on the type of geometry. For example, with `point` features you to explore distance measurement queries and ask what points are inside or outside of specific polygon objects. Polygon features, on the other hand, allow for a wider range of both measurement and spatial relationship queries.

An important distinction between these two types of queries is that measurement queries depend on the CRS of the data while spatial relationship queries do not. This is because `topological relationships`, the term used to describe spatial relationships, are invariant to rotation, translation and scaling transformations like those from that CRS transformations.

We'll work through examples of each of those types of queries.

Then we'll see an example of a very common spatial analysis that 
is a conceptual amalgam of those two types: **proximity analysis**.


## 6.0 Load and prep some data

Load the libraries we will use.

```{r, message=F}
library(sf)
library(tmap)
```

Let's read in the CA census tracts data and then take a look at its geometry and attributes.

```{r}
census_tracts = st_read("notebook_data/census/Tracts/cb_2013_06_tract_500k.shp")
plot(census_tracts$geometry)
```

```{r}
head(census_tracts)
```

Then we'll select just the `Alameda County` census tracts.

```{r}
census_tracts_ac = census_tracts[census_tracts$COUNTYFP=='001',]
plot(census_tracts_ac)
```

## 6.1 Measurement Queries

We'll start off with some simple measurement queries.

We can get the areas of each of our census tracts using the `st_area` function.

```{r}
st_area(census_tracts_ac)[1:10]
```

Okay! 

We got... 

numbers!

...?

<img src="http://www.pngall.com/wp-content/uploads/2016/03/Light-Bulb-Free-PNG-Image.png" width="20" align=left >  **Question**

1. What do those numbers mean?
2. What are the units?
3. And if we're not sure, how might be find out?


Let's take a look at our CRS.

```{r}
st_crs(census_tracts_ac)
```

Wow! We're working in an unprojected (aka geographic) CRS, with units of decimal degrees, but `sf` automatically gave us area measurements in square meters (rather than the rather irrational square degrees).

How did it do this? For unprojected CRS, `sf` calculates geodetic measurements (i.e. travel-distances across the earth's curved surface). It uses the `st_geod_area` function for this; see the `?st_area` documentation for details.

------------------

**That said, when doing spatial analysis, we will almost always want to work in a projected CRS since many spatial operations do not work with geographic CRSs.**

Time to project! We'll transform the data to the UTM Zone 10N, NAD83 CRS (EPSG 26910) which is appropriate for Northern California.

```{r}
census_tracts_ac_utm10 = st_transform(census_tracts_ac, 26910)
```

Now check it..especially look for the units.
```{r}
st_crs(census_tracts_ac_utm10)
```

Now let's try our area calculation again.

```{r}
st_area(census_tracts_ac_utm10)[1:10]
```

What if we compare areas calculated from our unprojected and projected CRS?

```{r}
print(st_area(census_tracts_ac)[[1]])
print(st_area(census_tracts_ac_utm10)[[1]])
```

Hmmm... The numbers are a bit different...specifically...

```{r}
st_area(census_tracts_ac)[[1]] - st_area(census_tracts_ac_utm10)[[1]]
```

----------------------------

You may have noticed that our census tracts already have an area column in them.

Let's also compare the calculated areas with the data in this column.

```{r}
print(st_area(census_tracts_ac)[[1]])
print(st_area(census_tracts_ac_utm10)[[1]])
print(census_tracts$ALAND[1])
```

<img src="http://www.pngall.com/wp-content/uploads/2016/03/Light-Bulb-Free-PNG-Image.png" width="20" align=left >  **Question**

What explains the discrepancy? Which areas are correct? Which are incorrect?

#### Doing more

We can also sum the area for Alameda county by wrapping our area calculation in a call to `sum`.

```{r}
sum(st_area(census_tracts_ac_utm10))

```

We can look up how large Alameda County is to check our work.The county is 739 miles<sup>2</sup>, which is around 1,914,001,213 meters<sup>2</sup>. I'd say we're pretty close!

```{r}
# Sum the area of all Alameda county Census Tracts dynamically in square miles...
sum(units::set_units(st_area(census_tracts_ac_utm10),mi^2))
```
```{r}
# Add the area of all Alameda County Census tracts to the data frame
census_tracts_ac_utm10$area_sqmi <-units::set_units(st_area(census_tracts_ac_utm10), mi^2)

# Check it by summing
print(sum(census_tracts_ac_utm10$area_sqmi))

# Take a look
head(census_tracts_ac_utm10,3)
```
Calculating the area of features and adding it to the dataframe is a useful operation because it allows us to convert count variables like population to densities.

------------

Also, you may have been wondering how R is managing to tell us the units of our measurements.

It turns out that `sf` depends on the `units` package to track units. 

This is super convenient! But there is a gotcha:

```{r}
# convert to square kilometers
sum(st_area(census_tracts_ac_utm10)) / (1000^2)
```

Oops! Our manual conversion to square kilometers gave us the right number but kept the now-wrong units!

Here's the proper way to convert:

```{r}
units::set_units(sum(st_area(census_tracts_ac_utm10)), km^2)
```

Much nicer! In case you're wondering how we knew the right abbreviation to use for kilometers,
check out the leftmost column in this reference table:

```{r}
# View(units::valid_udunits())
```

### Calculating Length or Permeter

As it turns out, we can similarly use the `st_length` operator to calculate the length or perimeter of a feature. Always take note of the output units!

```{r}
st_length(census_tracts)[1:10]
```

## 6.2 Spatial Relationship Queries

[Spatial relationship queries](https://en.wikipedia.org/wiki/Spatial_relation) consider how two geometries or sets of geometries relate to one another in space. For example, you may want to know what schools are located within the City of Berkeley or what East Bay Regional Parks have land within Berkeley. You may also want to combine a measurement query with a spatial relationship query. Example, you may want to know the total length of freeways within the city of Berkeley.

<img src="https://upload.wikimedia.org/wikipedia/commons/5/55/TopologicSpatialRelarions2.png" height="300px"></img>

Here is a list of some of the more commonly used `sf` spatial relationship operations.

- st_intersects
- st_within
- st_contains
- st_disjoint

These can be used to select features in one dataset based on their spatial relationship to another. In other works, you can use these operations to make spatial selections / create spatial subsets.

Enough talk. Let's work through some examples.

### What Alameda County Schools are in Berkeley?

First, load the `CA Places` data and select the city of Berkeley and save it to a sf dataframe. 

```{r}
places = st_read('notebook_data/census/Places/cb_2018_06_place_500k.shp')
berkeley = places[places$NAME=='Berkeley',]
plot(berkeley$geometry)
```

Then, load the Alameda County schools data and make it a spatial dataframe.

```{r}
schools_df = read.csv('notebook_data/alco_schools.csv')
schools_sf = st_as_sf(schools_df, 
                      coords = c('X','Y'),
                      crs = 4326)
```

Check that the two sf dataframes have the same CRS.

```{r}
st_crs(schools_sf) == st_crs(berkeley)
```

They don't have the same CRS so we need to align them. Let's transform (or reproject) the CRS of both
of these dataframes to UTM10N, NAD83 (EPSG 26910). This is a commonly used CRS for Northern CA data.
```{r}
# Transform data CRSs...
schools_utm10 <- st_transform(schools_sf, 26910)
berkeley_utm10 <- st_transform(berkeley, 26910)
```

If you look at the Schools data you will see that it has a `City` column. So we can subset the data by attribute to select the Schools in Berkeley. No need to do a spatial selection.

```{r}
berkeley_schools = schools_utm10[schools_utm10$City=='Berkeley',]
dim(berkeley_schools)
plot(berkeley_utm10$geometry)
plot(berkeley_schools$geometry, add=T)
```

That looks good and was relatively simple operation. But what if the schools data didn't have that city column? How could we identify the schools in Berkeley spatially?

```{r}
# Spatially select only the schools within Berkeley
berkeley_schools_spatial = schools_utm10[berkeley_utm10,]

# How many did we get
dim(berkeley_schools_spatial)

# Map the results
plot(berkeley_utm10$geometry)
plot(berkeley_schools_spatial$geometry, add=T)

```

**What just happened? Look closely at the spatial subset operation above.**

Interestingly, we have one more school in Berkeley based on the spatial selection!? Let's take a look.

```{r}
plot(berkeley_utm10$geometry)
plot(berkeley_schools_spatial$geometry, add=T)
plot(berkeley_schools$geometry,col="red", add=T)

```
Let's use an interactive `tmap` to zoom into the school that was not selected by attribute but was spatially selected.

```{r}
tmap_mode('view')

tm_shape(berkeley_utm10) +
  tm_borders() +
tm_shape(berkeley_schools_spatial) +
 tm_dots(col="black", size=.3) +
 tm_shape(berkeley_schools) +
 tm_dots(col="red", size=.1)
 
```


In a similar fashion, we can use the `st_disjoint` operator to select only those schools NOT spatial within Berkeley. 

> **NOTE**: The default spatial select operator is `st_intersects` - any other operator must be specified.

```{r}
# Select all Alameda County Schools NOT in Berkeley with the disjoint operator
berkeley_schools_disjoint = schools_utm10[berkeley_utm10, , op=st_disjoint]
plot(berkeley_schools_disjoint$geometry)
plot(berkeley_utm10, col=NA, border="red", add=T)

```

There is no need to memorize these spatial operators (aka predicates)! [Here](https://github.com/rstudio/cheatsheets/blob/master/sf.pdf) is a fantastic `sf` cheatsheet that lists and briefly explains all these common functions (and many more).


--------------------------------

### Protected Areas in Alameda County

Let's load a new dataset, the CA Protected Areas Database (CPAD), to demonstrate these spatial queries in more detail.

This dataset contains all of the protected areas (parks and the like) in California.

We will use this data and the Alameda County Census Data that we created earlier to ask "What protected areas are within Alameda County?"

First load the CPAD data (CA Protected Areas Database).
```{r}
pas = st_read('./notebook_data/protected_areas/CPAD_2020a_Units.shp')
```

What is the CRS of the PAS data?

Let's transform the data to match `census_tracts_ac_utm10`.

```{r}
pas_utm10 = st_transform(pas, st_crs(census_tracts_ac_utm10))
```

Let's plot the data in so that we know what to expect. CPAD is big so wait for it...
```{r}
plot(census_tracts_ac_utm10$geometry, col='red')
plot(pas_utm10$geometry, col='green', add=T)
```

We can see from our map that some of the protected areas are completely within Alameda County and some of them overlap. To get both of these cases we use the `st_intersects` operator, which is the default. Let's check it out.

```{r}
pas_intersects = pas_utm10[census_tracts_ac_utm10,]  #st_intersects
pas_within = pas_utm10[census_tracts_ac_utm10, , op=st_within] #st_within

```

We can use `tmap` to explore the difference in the results from `st_intersects` vs `st_within`
```{r}
tmap_mode('view')

tm_shape(census_tracts_ac_utm10)+
  tm_polygons(col="gray", border.col="grey") +
tm_shape(pas_intersects) +
  tm_borders(col="green") +
tm_shape(pas_within) +
  tm_borders(col='red')
```

What you can see from the above, is that by default, `st_intersects` returns the features that intersect but it does not **clip** the features to the boundary of Alameda County. For that, we would need to use a different spatial operation - `st_intersection`.

Let's try it!

```{r}
pas_in_ac = st_intersection(pas_utm10, census_tracts_ac_utm10)
```

Great! Now, if we scroll the resulting `sf` object we'll see that 
the `COUNTY` column of our resulting subset gives us a good sanity check on our results.

```{r}
head(pas_in_ac)
```

An overlay plot can also provide a nice check!

```{r}
tm_shape(census_tracts_ac_utm10) + 
  tm_polygons(col='gray', border.col='gray') +
tm_shape(pas_in_ac) + 
  tm_polygons(col = 'ACRES', palette = 'YlGn',
              border.col = 'black', lwd = 0.4, 
              alpha = 0.8,
              title =  'Protected areas in Alameda County, colored by area')
```

### st_intersects or st_intersection?

It really depends! But make sure you understand the difference. The `st_intersects` operator is fundamentally a logical, subsetting query that returns those features in the target dataframe that intersect the source geometry, in this case Alameda County census tracts.  On the other hand, `st_intersection` returns a new spatial dataframe that includes geometries from one dataframe that have been clipped to the boundary of the other dataframe. It also includes the attributes from both dataframes.


## Exercise: Spatial Relationship Query

It's your turn.

Write a spatial relationship query to create a new dataset containing only the BART stations in Berkeley.

Run the next two cells to load datasets containing Berkeley's city boundary and Alameda County's
schools and to reproject them to match the Berkeley_utm10 dataframe (EPSG: 26910).

Then in the following cell, write your own code to:
1. Spatially select the BART stations that are `within` Berkeley
2. Plot the Berkeley boundary and then overlay the selected BART stations.

To see the solution, look at the hidden text below.

```{r}
# load the Berkeley boundary
bart_df = st_read("notebook_data/transportation/bart.csv")
bart_sf = st_as_sf(bart_df, 
                   coords = c('lon','lat'),
                   crs = 4326)
  
# transform to EPSG:26910
bart_utm10 = st_transform(bart_sf, st_crs(berkeley_utm10))

# display
head(berkeley_utm10)
```
Plot the data together
```{r}
plot(bart_utm10$geometry)
plot(berkeley_utm10$geometry, border='blue', add=T)
```
Now, in the cell below, `write the code` to spatially select the Berkeley BART stations, then make the map.

```{r}
# YOUR CODE HERE:


```

### Solution hidden here!

<!--

# SOLUTION:

# get the intersection of the bart and Berkeley
bart_in_berkeley = bart_utm10[berkeley_utm10,]
# or
#bart_in_berkeley = st_intersection(bart_utm10, berkeley_utm10)

# plot the Berkeley border
tm_shape(berkeley_utm10) +
  tm_polygons(col='lightgrey') + 
  
tm_shape(bart_in_berkeley) + 
  tm_dots(col='purple', size=0.1)

-->

-------------------------------

## 6.3 Proximity Analysis

Now that we've seen the basic idea of spatial measurement and relationship queries,
let's take a look at a common analysis that combines those concepts: **promximity analysis**.

Proximity analysis seeks to identify all features in a focal feature set
that are within some maximum distance of features in a reference feature set.

A common workflow for this analysis is:

1. Buffer (i.e. add a margin around) the reference dataset, out to the maximum distance.
2. Run a spatial relationship query to find all focal features that intersect (or are within) the buffer.

---------------------------------

Let's read in our bike boulevard data again.

Then we'll find out which of our Berkeley schools are within a block's distance (200 meters) of the bike boulevards.

```{r}
bike_blvds = st_read('notebook_data/transportation/BerkeleyBikeBlvds.geojson')
plot(bike_blvds$geometry)
```

Of course, we need to reproject the boulevards to our projected CRS.

```{r}
bike_blvds_utm10 = st_transform(bike_blvds, st_crs(berkeley_utm10))
```

Now we can create our 200 meter bike boulevard buffers.

```{r}
bike_blvds_buf = st_buffer(bike_blvds_utm10, dist=200)
```

Now let's overlay everything.

```{r}
tm_shape(berkeley_utm10) + 
  tm_polygons(col = 'lightgrey') + 
tm_shape(bike_blvds_buf) + 
  tm_polygons(col = 'pink', alpha = 0.5) +
tm_shape(bike_blvds_utm10) + 
  tm_lines() + 
tm_shape(berkeley_schools_spatial) + 
  tm_dots(col = 'purple', size=0.2)
```

Great! Looks like we're all ready to run our intersection to complete the proximity analysis. At this point (pun intended) it is a spatial selection (or intersection) operation, just like what we have done previously in this lesson.

```{r}
schools_near_blvds = berkeley_schools_spatial[bike_blvds_buf,]
# or
#schools_near_blvds = st_intersection(schools_sf_utm10, bike_blvds_buf)
```

Now let's overlay again, to see if the schools we subsetted make sense.

```{r}
tm_shape(berkeley_utm10) + 
  tm_polygons(col = 'lightgrey') + 
tm_shape(bike_blvds_buf) + 
  tm_polygons(col = 'pink', alpha = 0.5) +
tm_shape(bike_blvds_utm10) + 
  tm_lines() + 
tm_shape(berkeley_schools_spatial) + 
  tm_dots(col = 'purple', size=0.2) +
tm_shape(schools_near_blvds) + 
  tm_dots(col = 'yellow', size=0.2)
```

Also note that if we want to find the pairwise distance matrix of the shortest distances between
our schools and the bike boulevards, we can use the `st_distance` function.

```{r, eval=F}
st_distance(berkeley_schools_spatial, bike_blvds_utm10)
```

Similarly, we could use the function `st_nearest_feature` to get a vector of the row index for the nearest bike boulevard to each school.
```{r}
st_nearest_feature(berkeley_schools_spatial, bike_blvds_utm10)
```

## Exercise: Proximity Analysis

Now it's your turn to try out a proximity analysis!

Run the next cell to load our BART-system data, reproject it to EPSG: 26910, and subset it to Berkeley.

Then in the following cell, write your own code to find all schools within walking distance (1 km) of a BART station.

As a reminder, let's break this into steps:
1. buffer your Berkeley BART stations to 1 km (**HINT**: remember your units!)
2. use the schools' `within` attribute to check whether or not they're within the buffers
3. subset the Berkeley schools using the object returned by your spatial relationship query

4. as always, plot your results for a good visual check!

To see the solution, look at the hidden text below.

```{r}
# load the BART stations from CSV
bart_stations = read.csv('notebook_data/transportation/bart.csv')
# coerce to an sf data.frame and set CRS to 4326
bart_stations_sf = st_as_sf(bart_stations, 
                             coords = c('lon', 'lat'),
                             crs = 4326)

# transform to utm zone 10 n (epsg:26910)
bart_stations_sf_utm10 = st_transform(bart_stations_sf, crs=26910)

# subset to berkeley
berkeley_bart = st_intersection(bart_stations_sf_utm10, berkeley_utm10)
```

```{r}
# YOUR CODE HERE:
# buffer the BART stations to 1 km

# spatially select the schools within the buffers

# Map with tmap
# plot the Berkeley boundary (for reference) in lightgrey

# add the BART stations (for reference) to the plot in green

# add the BART buffers (for check) in lightgreen

# add all Berkeley schools (for reference) in black

# add the schools near BART (for check) in yellow

```

### Solution hidden here!

<!--

# SOLUTION

# buffer the BART stations to 1 km
bart_buf = st_buffer(berkeley_bart, 1000)
# get schools within the buffers
bart_schools = st_intersection(berkeley_schools, bart_buf)

# plot the Berkeley boundary (for reference)
tm_shape(berkeley_utm10) + 
  tm_polygons(col='lightgrey') + 
# plot the BART stations (for reference)
tm_shape(berkeley_bart) + 
  tm_dots(col='green', size=.1) + 
# add the BART buffers (for check)
tm_shape(bart_buf) + 
  tm_borders(col='lightgreen') + 
# add all Berkeley schools (for reference)
tm_shape(berkeley_schools) + 
  tm_dots(col='black', size=.1) + 
# add the schools near BART (for check)
tm_shape(bart_schools) + 
  tm_dots(col='yellow', size=0.25)

-->

----------------------------------

## 6.4 Recap
Leveraging what we've learned in our earlier lessons, we got to work with map overlays and start answering questions related to proximity. Key concepts include:

- Measuring area and length
	- `st_area`, 
	- `st_length`
	- `st_distance`
- Relationship Queries
	- `st_intersects`, 
	- `st_intersection`
	- `st_within`, etc.
- Buffer analysis
	- `st_buffer`


---
<div style="display:inline-block;vertical-align:middle;">
<a href="https://dlab.berkeley.edu/" target="_blank"><img src ="assets/images/dlab_logo.png" width="75" align="left">
</a>
</div>

<div style="display:inline-block;vertical-align:middle;">
<div style="font-size:larger">&nbsp;D-Lab @ University of California - Berkeley</div>
<div>&nbsp;Team Geo<div>
</div>
        



